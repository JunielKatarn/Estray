/**
 * @file payload.hpp
 */

/*
 * The following license applies to the code in this file:
 *
 * **************************************************************************
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * **************************************************************************
 *
 * Author: Dr. RÃ¼diger Berlich of Gemfony scientific UG (haftungsbeschraenkt)
 * See http://www.gemfony.eu for further information.
 *
 * This code is based on the Beast Websocket library by Vinnie Falco, as published
 * together with Boost 1.66 and above. For further information on Beast, see
 * https://github.com/boostorg/beast for the latest release, or download
 * Boost 1.66 or newer from http://www.boost.org .
 */

#ifndef EVALUATOR_PAYLOAD_HPP
#define EVALUATOR_PAYLOAD_HPP

// Standard headers go here
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <memory>
#include <random>
#include <algorithm>

// Boost headers go here
#include <boost/function.hpp>
#include <boost/bind.hpp>
#include <boost/archive/xml_oarchive.hpp>
#include <boost/archive/xml_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/serialization/nvp.hpp>
#include <boost/serialization/map.hpp>
#include <boost/serialization/variant.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/shared_ptr.hpp>
#include <boost/serialization/base_object.hpp>
#include <boost/serialization/utility.hpp>
#include <boost/serialization/tracking.hpp>
#include <boost/serialization/split_member.hpp>
#include <boost/serialization/export.hpp>
#include <boost/asio.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/cstdint.hpp>
#include <boost/filesystem.hpp>

// Our own headers go here
#include "misc.hpp"

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/

class payload_base {
	 ///////////////////////////////////////////////////////////////
	 friend class boost::serialization::access;

	 template<class Archive>
	 void serialize(Archive & ar, const unsigned int version)
	 { /* nothing */ }

	 ///////////////////////////////////////////////////////////////

public:
	 payload_base() = default;
	 virtual ~payload_base() = default;
	 payload_base(const payload_base&) = default;

	 void process();
	 bool is_processed();

private:
	 virtual void process_() = 0;
	 virtual bool is_processed_() = 0;
};

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/

// Saving and loading of payload_base-derivatives through the base pointer
std::string to_string(const payload_base*);
payload_base *from_string(const std::string&);

// For debugging purposes: Direct output in XML and binary format
std::string to_xml(const payload_base*);
std::string to_binary(const payload_base*);
payload_base *from_binary(const std::string&);

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/

class command_container {
	 ///////////////////////////////////////////////////////////////
	 friend class boost::serialization::access;

	 template<class Archive>
	 void serialize(Archive & ar, const unsigned int version) {
		 ar
		 & BOOST_SERIALIZATION_NVP(m_command)
		 & BOOST_SERIALIZATION_NVP(m_payload_ptr);
	 }
	 ///////////////////////////////////////////////////////////////

public:
	 explicit command_container(
		 payload_command
	 );
	 command_container(
		 payload_command
		 , payload_base *
	 );
	 command_container(command_container&&) noexcept;
	 ~command_container();

	 command_container& operator=(command_container&&) noexcept;

	 // Deleted copy-constructors and assignment operator -- the class is non-copyable
	 command_container(const command_container&) = delete;
	 command_container& operator=(const command_container&) = delete;

	 // Reset to a new command and payload or clear the object
	 void reset(payload_command=payload_command::NONE, payload_base * = nullptr);

	 // Access to the command
	 void set_command(payload_command);
	 payload_command get_command() const noexcept;

	 // Processing of the payload (if any)
	 void process();
	 bool is_processed();

	 std::string to_string() const;
	 void from_string(const std::string&);

	 std::string to_xml() const;

private:
	 command_container() = default;

	 // Data
	 payload_command m_command{payload_command::NONE};
	 payload_base *  m_payload_ptr{nullptr};

	 mutable std::stringstream m_stringstream;
};

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/

class stored_number {
	 ///////////////////////////////////////////////////////////////
	 friend class boost::serialization::access;

	 template<class Archive>
	 void serialize(Archive & ar, const unsigned int version){
		 using boost::serialization::make_nvp;
		 ar & BOOST_SERIALIZATION_NVP(m_secret);
	 }
	 ///////////////////////////////////////////////////////////////

public:
	 stored_number() = default;
	 explicit stored_number(double secret);
	 stored_number(const stored_number& cp) = default;
	 ~stored_number() = default;

	 stored_number& operator=(const stored_number& cp) = default;

	 std::shared_ptr<stored_number> clone();

	 double value() const;

private:
	 double m_secret = 0.;
};

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/

class container_payload : public payload_base
{
	 ///////////////////////////////////////////////////////////////
	 friend class boost::serialization::access;

	 template<class Archive>
	 void serialize(Archive & ar, const unsigned int version){
		 using boost::serialization::make_nvp;
		 ar
		 & make_nvp("payload_base", boost::serialization::base_object<payload_base>(*this))
		 & BOOST_SERIALIZATION_NVP(m_data);
	 }
	 ///////////////////////////////////////////////////////////////

public:
	 // Initialize container with random numbers
	 template <typename dist_type, typename rng_type>
	 container_payload(
		 std::size_t size
		 , dist_type& dist
		 , rng_type& rng)
	 {
		 for(unsigned int i=0; i<size; i++){
			 this->add(std::shared_ptr<stored_number>(new stored_number(dist(rng))));
		 }
	 }

	 // Copy constructor
	 container_payload(const container_payload&);
	 // The destructor
	 ~container_payload() override = default;

	 // Assignment operator
	 container_payload& operator=(const container_payload&);

	 void sort();

	 std::size_t size() const;
	 std::shared_ptr<stored_number> member(std::size_t) const;
	 void add(std::shared_ptr<stored_number> p);

private:
	 // Only needed for de-serialization
	 container_payload() = default;

	 void process_() override;
	 bool is_processed_() override;

	 //-------------------------------------------------
	 // Data

	 std::vector<std::shared_ptr<stored_number>> m_data;
};

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/

class sleep_payload : public payload_base
{
	 ///////////////////////////////////////////////////////////////
	 friend class boost::serialization::access;

	 template<class Archive>
	 void serialize(Archive & ar, const unsigned int version){
		 using boost::serialization::make_nvp;
		 ar
		 & make_nvp("payload_base", boost::serialization::base_object<payload_base>(*this))
		 & BOOST_SERIALIZATION_NVP(m_sleep_time);
	 }
	 ///////////////////////////////////////////////////////////////

public:
	 // Initialize with the sleep duration in seconds (a double number, i.e. you can say "sleep 1.5 seconds)
	 explicit sleep_payload(double);

	 // Copy constructor
	 sleep_payload(const sleep_payload&) = default;
	 // The destructor
	 ~sleep_payload() override = default;

	 // Assignment operator
	 sleep_payload& operator=(const sleep_payload&) = default;

private:
	 // Only needed for de-serialization
	 sleep_payload() = default;

	 void process_() override;
	 bool is_processed_() override;

	 //-------------------------------------------------
	 // Data
	 double m_sleep_time = 0.;
};

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/
// Used for the serialization of the classes in this file

BOOST_SERIALIZATION_ASSUME_ABSTRACT(payload_base)
BOOST_CLASS_EXPORT_KEY(command_container)
BOOST_CLASS_EXPORT_KEY(stored_number)
BOOST_CLASS_EXPORT_KEY(container_payload)
BOOST_CLASS_EXPORT_KEY(sleep_payload)

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/

#endif /* EVALUATOR_PAYLOAD_HPP */
